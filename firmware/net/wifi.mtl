var wifi;;
var wifiscans;;

type Wifi=initW | gomasterW | masterW | gostationW _ | dhcpW _| stationW | reconnectW;;

// debug
#ifdef WIFI_DEBUG
fun _wifi_debug str= Secholn strcatlist "[wifi] " :: str :: nil; nil;;
#else
fun _wifi_debug str= nil;;
#endif

const RT2501_S_BROKEN=0;;
const RT2501_S_IDLE=1;;
const RT2501_S_SCAN=2;;
const RT2501_S_CONNECTING=3;;
const RT2501_S_CONNECTED=4;;
const RT2501_S_MASTER=5;;

const IEEE80211_M_MANAGED=0;;
const IEEE80211_M_MASTER=1;;

var wifitry;;
var master=0;;

#include utils/utils.mtl
#include protos/dhcp_protos.mtl
#include protos/udp_protos.mtl
#include protos/dns_protos.mtl
#include protos/net_protos.mtl
#include protos/env_protos.mtl
#include protos/leds_protos.mtl
#include protos/config_protos.mtl

fun _scanserialize l=
    if l!=nil then
    let hd l->[ssid mac bssid rssi channel rateset encryption] in
    ssid::"\0"::mac::bssid::(itoh4 rssi)::(itoh4 channel)::(itoh4 rateset)::(itoh4 encryption)::
    _scanserialize tl l;;

fun scanserialize l=
    (itoh4 listlen l)::_scanserialize l;;

fun _wifi_dump_scan l0=
    _wifi_debug "## DUMPSCAN >>>>";
    for l=l0;l!=nil;tl l do
    let hd l->[ssid mac bssid rssi channel rateset encryption] in
    (
        _wifi_debug strcatlist "## SCAN " :: ssid :: nil;
        _wifi_debug strcatlist "mac: " :: (MAC_to_str mac 0 1) :: nil;
        _wifi_debug strcatlist "bssid: " :: (MAC_to_str bssid 0 1) :: nil;
        _wifi_debug strcatlist "rssi: " :: (itoa rssi) :: nil;
        _wifi_debug strcatlist "channel: " :: (itoa channel) :: nil;
        _wifi_debug strcatlist "rateset: " :: (itoa rateset) :: nil;
        _wifi_debug strcatlist "encryption: " :: (itoa encryption) :: nil;
        0
    );
    l0;;

fun ssidlen s i=
    if i>=strlen s then i
    else if !strget s i then i
    else ssidlen s i+1;;

fun scanunserialize s n i0=
    if n>0 then
    let ssidlen s i0 -> j in
    let j+1->i in
    [
        strsub s i0 j-i0
        strsub s i 6
        strsub s i+6 6
        htoi strsub s i+12 8
        htoi strsub s i+20 8
        htoi strsub s i+28 8
        htoi strsub s i+36 8
    ]::scanunserialize s n-1 i+44;;


const IEEE80211_CRYPT_NONE=0;;
const IEEE80211_CRYPT_WEP64=1;;
const IEEE80211_CRYPT_WEP128=2;;
const IEEE80211_CRYPT_WPA=3;;
const IEEE80211_CRYPT_WPA_UNSUPPORTED=4;;

const IEEE80211_AUTH_OPEN=0;;
const IEEE80211_AUTH_SHARED=1;;

fun scancmpssid a b=
    let a->[sa _ _ _ _ _ _] in
    let b->[sb _ _ _ _ _ _] in
    strcmp sa sb;;

fun wifi_init rescan=
    set wifitry=nil;
    let envget -> env in
    if env==nil then
    (
        setleds RGB_VIOLET;
        set wifi=initW;
        if rescan then set wifiscans=nil;
        if master then
        (
            set netip=netip_master;
            set netmask=netmask_master;
            set netgateway=netgateway_master;
            0
        )
        else
        (
            if config_get_dhcp then set netip=netip_empty
            else
            (
                set netmask=config_get_netmask;
                set netgateway=config_get_net_gw;
                dns_add_new_srv config_get_net_dns 1;
                set netip=config_get_net_ip
            );
            0
        );
        0
    )
    else
    (
        setleds RGB_GREEN;
        set mymac=netMac;
        set wifi=stationW;
        env_restore env;
        envset nil;
        nil
    );
    0;;

var laststate;;

fun wifibyssid x v=let x->[s _ _ _ _ _ _] in (s!=nil)&& !strcmp v s;;


var retrytime;;

fun _wifiwepkey val i len=
    if i<len then
    (htoi strsub val i 2)::_wifiwepkey val i+2 len;;

fun wifiwepkey val=
    let strlen val -> len in
    if len==5 || len==13 then val
    else let strreplace val ":" "" -> val in
    let if len<10 then 0 else if len<26 then 5 else 13 -> len in
    listtostr _wifiwepkey val 0 len<<1;;

fun wificrypttype crypt key=
    if crypt==1 then if 5==strlen key then IEEE80211_CRYPT_WEP64 else IEEE80211_CRYPT_WEP128
    else if crypt==2 then IEEE80211_CRYPT_WPA
    else IEEE80211_CRYPT_NONE;;

fun wifiAuth=
    setleds RGB_AMBER;
    if wifiscans==nil then 0
    else
        let config_get_wifi_crypt -> crypt in
        let config_get_wifi_auth -> auth in
        let if crypt==1 then wifiwepkey config_get_wifi_key0
            else if crypt==2 then config_get_wifi_pmk -> key in
            (
                dump key;
                set wifitry=time;
                netAuth hd wifiscans auth (wificrypttype crypt key) key;    //## ajouter les paramÃ¨tres de crypto
                1
            );;

fun wifi_check =
    if netState==RT2501_S_IDLE then
    match wifi with
    (initW -> nil)
    |(_ ->
        _wifi_debug "######### wifi lost";
        set wifi=reconnectW;
        ears_stop 1; // make sure that ears are not moving while we're reconnecting.
#ifdef WIFI_REBOOT_ON_LOST
        _wifi_debug "######### rebooting";
        reboot 0x0407FE58 0x13fb6754;
#endif
        0
    )
    ;;

fun wifi_run=
    let netState -> state in
    (
        if state!=laststate then (
            _wifi_debug strcatlist "wifi state: " :: (itoa state) :: nil
        );
        let match wifi with
        (stationW -> nil)
        |(initW -> if state==RT2501_S_IDLE then
                (
                    set mymac=MAC_to_str netMac 0 1;
                    setleds RGB_AMBER;
                    if master then
                    (
                        _wifi_dump_scan set wifiscans=sort netScan nil #scancmpssid;
                        netSetmode IEEE80211_M_MASTER (strcat "Nabaztag" ctoh strget mymac 5) 1;
                        _wifi_debug strcatlist mymac :: " -------------gomaster" :: nil;
                        gomasterW
                    )
                    else
                    (
                        if wifiscans==nil then
                        (
                            let config_get_wifi_ssid -> ssid in
                            let if strlen ssid then ssid else nil -> ssid in
                            let netScan ssid -> lscan in
                            let sort lscan #scancmpssid -> l in
                            let if ssid==nil then l else select l ssid #wifibyssid-> l in
                            _wifi_dump_scan set wifiscans=l
                        );
                        if wifiAuth then
                        (
                            _wifi_debug strcatlist config_get_wifi_ssid :: ":-------------gostation" :: nil;
                            gostationW [0 time]
                        )
                    )
                )
            )
        |(gomasterW -> if state==RT2501_S_MASTER then
                (
                    setleds RGB_BLUE;
                    _wifi_debug "-------------master";
                    dhcp_start_srv;
                    masterW)
            )
        |(masterW -> if !master then
                    (
                        wifi_init 1;
                        resetudp;
                        netSetmode IEEE80211_M_MANAGED nil 11;
                        nil)
            )
        |(gostationW x-> if state==RT2501_S_CONNECTED then
                (
                    _wifi_debug "-------------dhcp";
                    if config_get_dhcp then dhcp_start_client;
                    dns_start_client;
                    dhcpW time
                )
            )
        |(dhcpW t-> if netip!=netip_empty then
                (
                    _wifi_debug "-------------station";
                    stationW
                )
                else if (time-t)>3 then // retry dhcp client
                (
                    dhcp_start_client;
                    dhcpW time
                )
            )
        |(reconnectW ->
            netSetmode IEEE80211_M_MANAGED nil 11;
            if wifiAuth then
            (
                _wifi_debug strcatlist config_get_wifi_ssid :: ":-------------gostation" :: nil;
                gostationW [0 time]
            )
         )
        -> nwifi in
        if nwifi!=nil then set wifi=nwifi;
        set laststate=state
    );
    if retrytime!=time then
    (
        set retrytime=time;
        nettime;
        dns_time;
        0
    );
    wifi_check;
    JobRun;;


#include net/dhcp.mtl
#include ipv4/udp.mtl
#include net/dns.mtl
#include net/net.mtl
#include utils/env.mtl
#include hw/leds.mtl
#include utils/config.mtl
