/**
 * Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

// https://forth-standard.org/
// https://www.forth.org/Ting/Forth-for-the-Complete-Idiot/Forth-79-Handy-Reference.pdf

type Forth=[
    stack               // data stack
    rstack              // return stack
    pc                  // program counter
    state               // normal (0) or compilation state (-1)
    output              // list of collected output strings
    new_word_name       // name of the word being defined if in compilation state
    new_word_definition // list of Words being defined if in compilation state
];;

type Word=[
    name    // name of the defined word
    code    // array of Words if a colon
    func    // function if primitive
    int     // data field - integer value for variables/constants
];;

const FORTH_TRUE = -1;;
const FORTH_FALSE = 0;;
const FORTH_STATE_NORMAL = 0;;
const FORTH_STATE_COMPILATION = -1;;

// The dictionary is a list of Words
var forth_dictionary;;

proto forth_get_word 2;;

#include forth/stack.mtl
#include forth/arithmetic.mtl
#include forth/comparison.mtl
#include forth/logical.mtl
#include forth/output.mtl
#include forth/misc.mtl
#include forth/dictionary.mtl

fun forth_tokenize s=
    if s=="" then nil
    else
        let strstr s " " 0 -> p in
        if p==nil then s::nil
        else let strsub s 0 p -> word in
             let strsub s (p+1) ((strlen s) - (p+1)) -> rest in
             word :: forth_tokenize rest
        ;;


fun forth_word_list_to_array words =
    let 0 -> i in
    let tabnew [name:"" func:nil] (listlen words) -> t in (
        for p=words; p!=nil; tl p do
        (
            set t.i=hd p;
            set i=i+1
        );
        t
    );;

fun forth_print_word w=
    Secho w.name; Secho " [";
    if w.func!=nil then (Secho "func"; 0)
    else if w.code!=nil then (Secho "code"; 0)
    else (Secho "int "; Iecho w.int; 0);
    Secholn "]";;

proto forth_execute_word_code 2;;

/**
 * Execute a single word.
 * Update the program counter and state as needed.
 */
fun forth_execute_word f word=
    Secho "pc: "; Iecho f.pc; Secho " word: "; forth_print_word word;
    set f.pc = f.pc + 1;

    if word.func == #forth_colon then (
        // Enter compilation state
        set f.state = FORTH_STATE_COMPILATION;
        set f.new_word_name = nil;
        set f.new_word_definition = nil;
        0

    ) else if word.func != nil then (
        // Execute primitive function
        call word.func [f]
    )
    else if word.code != nil then (
        // Call a colon-defined word
        forth_execute_word_code f word.code
    )
    else (
        // Push integer value onto the stack
        forth_push f word.int
    );
    dumpListI f.stack;
    0;;

/**
 * Run a sequence of Words as code, managing the return stack for nested calls.
 */
fun forth_execute_word_code f code=
    forth_rpush f f.pc;
    set f.pc = 0;
    while (f.pc != nil) && (f.pc < (tablen code)) do
        let code.(f.pc) -> word in
            forth_execute_word f word;
    set f.pc = forth_rpop f;
    0;;


// var text = "5 2 + 10 * dup 1 + >";;
// var text = ": bla 1 + exit 10 + ; 5 2 + bla exit 100 +";;
// var text = "1 2 3 4 dup";;
// var text = "9 8 7 1 2 over";;
// var text = "9 8 7 1 2 1 pick";;
// var text = ": test dup >r 10 + r> * ; 10 test";;
// var text = "' bla";;
var text = "1 . space 2 . space 3 . space 4 . ( test aa bb ) space 65 emit";;

fun inter text=
    if forth_dictionary==nil then forth_init_dictionary;

    let 0 -> start in // current token start
    let 0 -> end in  // current token end
    let 0 -> parentheses in // parentheses depth
    let strlen text -> text_len in
    let [stack:nil rstack:nil pc:0] -> f in (
        while (f.pc != nil) && (end != text_len) do (
            // TODO Skip leading spaces
            set end = strstr text " " start;
            if end == nil then set end = text_len;
            let strsub text start (end-start) -> cur in (
                set start = end + 1;
                let forth_get_word cur forth_dictionary -> word in (
                    if word.func == #forth_p then ( // open parentheses
                        set parentheses = parentheses + 1
                    );

                    if parentheses > 0 then ( // inside parentheses
                        if !strcmp cur ")" then set parentheses = parentheses - 1;
                        0

                    ) else if f.state == FORTH_STATE_COMPILATION then (  // compilation state
                        if word.func == #forth_semi then (
                            set f.state = FORTH_STATE_NORMAL;
                            let forth_word_list_to_array (rev f.new_word_definition nil) -> code in
                            set forth_dictionary=[ name:f.new_word_name code:code ]::forth_dictionary;
                            set f.new_word_name = nil;
                            set f.new_word_definition = nil;
                            0
                        ) else if f.new_word_name == nil then (
                            // first word after ":" is the new word's name
                            set f.new_word_name = cur;
                            0
                        ) else (
                            // add word to the latest defined word's code
                            set f.new_word_definition = word :: f.new_word_definition;
                            0
                        )

                    ) else ( // normal state
                        forth_execute_word f word
                    )
                )
            )
        );
        if f.output != nil then (
            Secho "Output:";
            Secholn strcatlist (rev f.output nil)
        );
        f
    );;
