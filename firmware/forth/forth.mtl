/**
 * Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

// https://forth-standard.org/
// https://www.forth.org/Ting/Forth-for-the-Complete-Idiot/Forth-79-Handy-Reference.pdf
// https://win32forth.sourceforge.net/doc/Guide/primer.htm

type Forth=[
    stack               // data stack
    rstack              // return stack
    cstack              // control stack
    pc                  // program counter
    state               // normal (0) or compilation state (-1)
    output              // list of collected output strings
    new_word_name       // name of the word being defined if in compilation state
    new_word_definition // list of Words being defined if in compilation state
];;

type Word=[
    name                // name of the defined word
    code                // array of Words if a colon
    immediate           // true if immediate word
    func                // function if primitive
    int                 // data field - integer value for variables/constants
];;

type Interpreter=[
    start               // current token start
    end                 // current token end
    end_ln              // next end of line position
    parentheses         // parentheses depth
    input               // input text
    text_len            // length of the input text
    token               // current token
];;

const FORTH_TRUE = -1;;
const FORTH_FALSE = 0;;
const FORTH_STATE_NORMAL = 0;;
const FORTH_STATE_COMPILATION = -1;;

// The dictionary is a list of Words
var forth_dictionary;;

proto forth_get_word 2;;
proto forth_word_list_to_array 1;;

#include forth/stack.mtl
#include forth/arithmetic.mtl
#include forth/comparison.mtl
#include forth/logical.mtl
#include forth/output.mtl
#include forth/misc.mtl
#include forth/dictionary.mtl

fun forth_word_list_to_array words =
    let 0 -> i in
    let tabnew [name:"" func:nil] (listlen words) -> t in (
        for p=words; p!=nil; tl p do
        (
            set t.i=hd p;
            set i=i+1
        );
        t
    );;

fun forth_print_word w=
    Secho w.name; Secho " [";
    if w.func!=nil then (Secho "func"; 0)
    else if w.code!=nil then (Secho "code"; 0)
    else (Secho "int "; Iecho w.int; 0);
    Secholn "]";;

proto forth_execute_word_code 2;;

/**
 * Execute a single word.
 * Update the program counter and state as needed.
 */
fun forth_execute_word f word=
    Secho "pc: "; Iecho f.pc; Secho " word: "; forth_print_word word;
    set f.pc = f.pc + 1;

    if word.func == #forth_colon then (
        // Enter compilation state
        set f.state = FORTH_STATE_COMPILATION;
        set f.new_word_name = nil;
        set f.new_word_definition = nil;
        0

    ) else if word.func != nil then (
        // Execute primitive function
        call word.func [f]
    )
    else if word.code != nil then (
        // Call a colon-defined word
        forth_execute_word_code f word.code
    )
    else (
        // Push integer value onto the stack
        forth_push f word.int
    );
    // dumpListI f.stack;
    0;;

// TODO recursive words

/**
 * Run a sequence of Words as code, managing the return stack for nested calls.
 */
fun forth_execute_word_code f code=
    forth_rpush f f.pc;
    set f.pc = 0;
    while (f.pc != nil) && (f.pc < (tablen code)) do
        let code.(f.pc) -> word in
            forth_execute_word f word;
    set f.pc = forth_rpop f;
    0;;

/**
 * Extract the next token from the input text.
 * Tokens are separated by spaces or newlines.
 */
fun forth_get_token i=
    set i.end = strstr i.input " " i.start;
    set i.end_ln = strstr i.input "\n" i.start;
    if (i.end_ln != nil) && ((i.end == nil) || (i.end_ln < i.end)) then set i.end = i.end_ln;
    if i.end == nil then set i.end = i.text_len;
    // Skip leading spaces
    while (i.start < i.end) && ((strget i.input i.start) == 32) do set i.start = i.start + 1;
    set i.token = strsub i.input i.start (i.end-i.start);
    set i.start = i.end + 1;
    0;;

// var text = "5 2 + 10 * dup 1 + >";;
// var text = ": bla 1 + exit 10 + ; 5 2 + bla exit 100 +";;
// var text = "1 2 3 4 dup";;
// var text = "9 8 7 1 2 over";;
// var text = "9 8 7 1 2 1 pick";;
// var text = ": test dup >r 10 + r> * ; 10 test";;
// var text = "' bla";;
// var text = "
// : bla 1 + exit 10 + ; 5 2 + bla . space
// 1 . space 2 . space 3 . space 4 . ( test aa bb )
// space 65 emit";;
var text = ": bla begin dup . 1 - dup 0 = until ; 5 bla";;

fun inter text=
    if forth_dictionary==nil then forth_init_dictionary;

    let [start:0 end:0 end_ln:0 parentheses:0 input:text text_len:(strlen text) token:nil] -> i in
    let [stack:nil rstack:nil pc:0] -> f in (
        while (f.pc != nil) && (i.end != i.text_len) do (
            forth_get_token i;
            let forth_get_word i.token forth_dictionary -> word in (
                // TODO \ comment to end of line

                if word.func == #forth_p then ( // open parentheses
                    set i.parentheses = i.parentheses + 1
                );

                if i.parentheses > 0 then ( // inside parentheses
                    if !strcmp i.token ")" then set i.parentheses = i.parentheses - 1;
                    0

                ) else if f.state == FORTH_STATE_COMPILATION then (  // compilation state
                    if word.immediate == FORTH_TRUE then (
                        // immediate word, execute now
                        forth_execute_word f word

                    ) else (
                        Secho "--> compiling "; Secho i.token; Secholn "";
                        if f.new_word_name == nil then (
                            // first word after ":" is the new word's name
                            set f.new_word_name = i.token;
                            0
                        ) else (
                            // add word to the latest defined word's code
                            set f.new_word_definition = word :: f.new_word_definition;
                            0
                        )
                    )

                ) else ( // normal state
                    forth_execute_word f word
                )
            )
        );
        if f.output != nil then (
            Secho "Output:";
            Secholn strcatlist (rev f.output nil)
        );
        f
    );;
