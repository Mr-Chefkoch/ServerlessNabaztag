/**
 * Forth interpreter
 * Copyright (c) 2025 Andrea Bonomi
 * This code is licensed under the MIT License
 */

// https://forth-standard.org/
// https://www.forth.org/Ting/Forth-for-the-Complete-Idiot/Forth-79-Handy-Reference.pdf
// https://win32forth.sourceforge.net/doc/Guide/primer.htm

type Forth=[
    stack               // data stack
    rstack              // return stack
    cstack              // control stack
    pc                  // program counter
    state               // normal (0) or compilation state (-1)
    output              // list of collected output strings
    new_word_name       // name of the word being defined if in compilation state
    new_word_definition // list of Words being defined if in compilation state
];;

type Word=[
    name                // name of the defined word
    code                // array of Words if a colon
    func                // function if primitive
    int                 // data field - integer value for variables/constants
    str                 // data field - string value
    wstack              // data field - stack of Words
    immediate           // true if immediate word
];;

type Interpreter=[
    start               // current token start
    end                 // current token end
    end_ln              // next end of line position
    parentheses         // parentheses depth
    input               // input text
    text_len            // length of the input text
    token               // current token
    quoted              // true if the token is a quoted string
];;

const FORTH_TRUE = -1;;
const FORTH_FALSE = 0;;

const FORTH_STATE_NORMAL = 0;;
const FORTH_STATE_COMPILATION = -1;;
const FORTH_SPACE = 32;; // ASCII space
const FORTH_DOUBLE_QUOTE = 34;; // ASCII " (double quote)

// The dictionary is a list of Words
var forth_dictionary;;

proto forth_get_word 2;;
proto forth_word_list_to_array 1;;

#include forth/stack.mtl
#include forth/logical.mtl
#include forth/arithmetic.mtl
#include forth/comparison.mtl
#include forth/output.mtl
#include forth/wstack.mtl
#include forth/control.mtl
#include forth/misc.mtl
#include forth/dictionary.mtl

fun forth_word_list_to_array words =
    let 0 -> i in
    let tabnew [name:"" func:nil] (listlen words) -> t in (
        for p=words; p!=nil; tl p do
        (
            set t.i=hd p;
            set i=i+1
        );
        t
    );;

fun forth_print_word w=
    if w.int != nil then (Iecholn w.int; 0)
    else if w.str != nil then (Secho w.str; Secholn " [str]"; 0)
    else (
    Secho w.name; Secho " [";
    if w.func!=nil then (Secho "func"; 0)
    else if w.code!=nil then (Secho "code"; 0)
    else (Secho "int "; Iecho w.int; 0);
    Secholn "]"; 0
    );;

proto forth_execute_word_code 2;;

/**
 * Execute a single word.
 * Update the program counter and state as needed.
 */
fun forth_execute_word f word=
    Secho "pc: "; Iecho f.pc; Secho " word: "; forth_print_word word;
    set f.pc = f.pc + 1;
    // Execute primitive function
    if word.func != nil then call word.func [f]
    // Execute a colon-defined word
    else if word.code != nil then forth_execute_word_code f word.code
    // Push the word onto the stack
    else forth_push f word
    ;;

// TODO recursive words

/**
 * Run a sequence of Words as code, managing the return stack for nested calls.
 */
fun forth_execute_word_code f code=
    forth_rpush f [int:f.pc];
    set f.pc = 0;
    while (f.pc != nil) && (f.pc < (tablen code)) do
        let code.(f.pc) -> word in
            forth_execute_word f word;
    let forth_rpop f -> ret_addr in
        set f.pc = ret_addr.int;
    0;;

/**
 * Extract the next token from the input text.
 * Tokens are separated by spaces or newlines.
 */
fun forth_get_token i=
    set i.end = strstr i.input " " i.start;
    set i.end_ln = strstr i.input "\n" i.start;
    if (i.end_ln != nil) && ((i.end == nil) || (i.end_ln < i.end)) then set i.end = i.end_ln;
    if i.end == nil then set i.end = i.text_len;
    // Skip leading spaces
    while (i.start < i.end) && ((strget i.input i.start) == FORTH_SPACE) do set i.start = i.start + 1;
    // Handle quoted strings
    if (strget i.input i.start) == FORTH_DOUBLE_QUOTE then (
        set i.start = i.start + 1; // skip opening quote
        set i.end = strstr i.input "\"" (i.start) + 1;
        set i.token = strsub i.input i.start (i.end-i.start);
        set i.start = i.end + 2; // skip closing quote and following space
        set i.quoted = 1
    ) else (
        set i.token = strsub i.input i.start (i.end-i.start);
        set i.start = i.end + 1;
        set i.quoted = 0
    );
    0;;

fun forth_new_word token=
    if is_numeric token then
        [int:(atoi token)]
    else
        [str:token];;

// var text = "5 2 + 10 * dup 1 + >";;
// var text = ": bla 1 + exit 10 + ; 5 2 + bla exit 100 +";;
// var text = "1 2 3 4 dup";;
// var text = "9 8 7 1 2 over";;
// var text = "9 8 7 1 2 1 pick";;
// var text = ": test dup >r 10 + r> * ; 10 test";;
// var text = "' bla";;
var text = "
: bla 1 + exit 10 + ;
5 2 + bla . space
1 . space 2 . space 3 . space 4 . ( test aa bb ) space 65 emit cr
Spaghetti . cr
nil 10 :: 20 :: 30 :: dup dup . space tl . space . cr
\"ciao mondo\" . cr
: test2 \"v: \" . dup . space if \"true\" . else \"false\" . then cr ;
0 test2
1 test2
: test3 \"v: \" . dup . space if \"true\" . then cr ;
0 test3
1 test3
";;
// var text = ": bla begin dup . 1 - dup 0 = until ; 5 bla \"ciao\" emit";;
// var text = "\"ciao ciao\" emit";;

fun inter text=
    if forth_dictionary==nil then forth_init_dictionary;

    let [start:0 end:0 end_ln:0 parentheses:0 input:text text_len:(strlen text) token:nil] -> i in
    let [stack:nil rstack:nil pc:0] -> f in (
        while (f.pc != nil) && (i.end != i.text_len) do (
            forth_get_token i;
            let if i.quoted then nil else forth_get_word i.token forth_dictionary -> word in (
                if word == nil then set word = forth_new_word i.token;
                // TODO \ comment to end of line

                if word.func == #forth_p then ( // open parentheses
                    set i.parentheses = i.parentheses + 1
                );

                if i.parentheses > 0 then ( // inside parentheses - ignore tokens until closing parenthesis
                    if !strcmp i.token ")" then set i.parentheses = i.parentheses - 1;
                    0
                ) else if (strlen i.token) == 0 then ( // empty token, skip
                    0
                ) else if word.func == #forth_colon then ( // start of new word definition
                    if f.state == FORTH_STATE_COMPILATION then (
                        set f.output = "\nError: Nested ':' not allowed\n" :: f.output;
                        forth_exit f
                    ) else (
                        set f.state = FORTH_STATE_COMPILATION;
                        set f.new_word_name = nil;
                        set f.new_word_definition = nil;
                        0
                    )
                ) else if word.func == #forth_semi then ( // end of new word definition
                    if f.state != FORTH_STATE_COMPILATION then (
                        set f.output = "\nError: ';' without matching ':'\n" :: f.output;
                        forth_exit f
                    ) else if f.new_word_name == nil then (
                        set f.output = "\nError: ';' without word name\n" :: f.output;
                        forth_exit f
                    ) else (
                        // Finish the new word definition
                        let forth_word_list_to_array (rev f.new_word_definition nil) -> code in
                            set forth_dictionary = [ name:f.new_word_name code:code ]::forth_dictionary;
                            set f.new_word_name = nil;
                            set f.new_word_definition = nil;
                            set f.state = FORTH_STATE_NORMAL;
                            0
                    )

                ) else if f.state == FORTH_STATE_COMPILATION then (  // compilation state
                    if word.immediate == FORTH_TRUE then (
                        // immediate word, execute now
                        forth_execute_word f word

                    ) else (
                        // Secho "--> compiling "; Secho i.token; Secholn "";
                        if f.new_word_name == nil then (
                            // first word after ":" is the new word's name
                            set f.new_word_name = i.token;
                            0
                        ) else (
                            // add word to the latest defined word's code
                            set f.new_word_definition = word :: f.new_word_definition;
                            0
                        )
                    )

                ) else ( // normal state
                    forth_execute_word f word
                )
            )
        );
        if f.output != nil then (
            Secho "Output:";
            Secholn strcatlist (rev f.output nil)
        );
        f
    );;
