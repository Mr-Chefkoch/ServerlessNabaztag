// VLISP - Feb 06 - by Sylvain Huet
// Metal

proto main 0;;
proto setRunState 1;;
proto getRunState 0;;
proto evalTrame 1;;

// XMPP ECHO DEBUG
fun Xw str =
    Secholn str;;
fun Xx i =
    Iecholn i;;

// ping echo debug
fun Pingw str = nil;; //Secholn str;;

// dns echo debug
fun Dnsw str = nil;; //Secholn str;;

// programs debug
fun Progw str = nil;; //Secholn strcatlist "[program] " :: str :: nil;;

// streaming debug
fun Streamw str = nil;; //Secholn strcatlist "[streaming] " :: str :: nil;;

// #define SIMU

// chose one
// #define PING
// #define XMPP
#define SERVERLESS

#define WEBSERVER
#define NOMINAL

// set doPing to something else than nil to activate ping
var doPing = nil ;;
// recording
var recording = 0;;

#ifdef NOMINAL
#define AUDIOLIB;;
#define EARSLIB;;
#define INFOLIB;;
#define RECLIB;;
#endif

const HARDWARE=4;;

proto buttoncheckevent 0;;

//
// Etats generaux
var gItState = 0;;          // interactif
var gSleepState = 1;;       // sleeping
var gStreamingState = 0;;   // streaming
var gProcessingState = 0;;  // processing a program
var gProcessingWaitState = 0;;  // executing a "wait" command in a program. when checking this var, check gProcessingState first, as it is not always reseted to 0
var gBusyState = 0;;        // busy (incoming message queue full)
var gItApp = nil;;          // the name of the interactive application
var gEarInited = 0;;        // si les oreilles ont été initialisées.
var gRegistrationError = 0;;// registration error during login

proto itNoteEarTouched 3;;

#include net/net_vars.mtl

const BYTECODE_REVISION_STR = "$Rev: __DATE__ $";;
fun getBytecodeRevision =
    strsub BYTECODE_REVISION_STR 6 ((strlen BYTECODE_REVISION_STR) - 8);;


#include utils/utils.mtl
#include hw/leds.mtl


// ---------------- dns prototypes

proto addnewdns 2;;
proto dnslisttostr 0;;
proto dnslistfromdhcp 1;;

// ---------------- end dns prototypes


#include utils/md5.mtl
#include utils/b64.mtl
#include utils/xmlparser.mtl
#include utils/config.mtl

#ifdef SIMU
#include ipv4/tcpudp_emu.mtl
#else
#include ipv4/arp.mtl
#include ipv4/udp.mtl
#include ipv4/tcp.mtl
#include ipv4/udp.mtl
#include net/dhcp.mtl
#include net/net.mtl
#endif

#include net/dns.mtl
#include net/http.mtl
#include srv/time.mtl

/**
    Les différents états de la boucle principale.
*/
type Run= configstartRun | configwaitRun _ | interactiveReqWaitRun _ |
#ifdef PING
    pingstartRun | pingwaitRun _| stdWaitRun _ | pingRequestWaitRun _ |
#endif
    rscLoadNextRun | rscLoadWaitRun _ | chorCmdRun _ |streamCmdRun _ | waitCmdRun _ | cmdEvalOne _ | idleRun | sleepRun |
#ifdef RECLIB
    recordRun | recordStartRun |
#endif
    earResetWaitRun _ | xmppLoginRun | xmppReconnectRun _ ;;

var run;;

proto earInit 0;;

#ifdef XMPP
#include srv/xmpp.mtl
#else
fun XmppSessionRequestResource newRes = 0 ;;
fun XmppSessionSendButtonMsg btn withEvent eventValue = 0 ;;
fun XmppSessionSendEarMsg leftValue rightValue = 0 ;;
var senddata=0;;
var currentTrameID=0;;
#endif

#ifdef RECLIB
#include utils/reclib.mtl
#endif

#ifdef AUDIOLIB
#include utils/audiolib.mtl
#endif

#ifdef EARSLIB
#include hw/ears.mtl
#endif

#ifdef INFOLIB
#include srv/info.mtl
#endif

#include srv/surprise.mtl
#include srv/crontab.mtl

#include utils/hooks.mtl

proto hookEars 2;;
proto hookRfid 1;;

proto hookClick 1;;
proto hookDblClick 1;;



//-------------------



#include net/wifi.mtl
#include utils/env.mtl

#ifdef NOMINAL

const tab_osc={
    0 0 0 0 0 0 1 1 2 3 3 4 5 6 7 8
    9 10 12 13 15 16 18 19 21 23 25 27 29 31 33 35
    37 39 42 44 46 49 51 54 56 59 62 64 67 70 73 76
    79 81 84 87 90 93 96 99 103 106 109 112 115 118 121 124
};;


fun osc x=
    let (x>>6)&3 -> q in
    let x&255 -> x in
    if q==0 then tab_osc.x
    else if q==1 then 255-tab_osc.(127-x)
    else if q==2 then 255-tab_osc.(x-128)
    else tab_osc.(255-x);;


var pingsrv;;
var broadcasturl;;
var recorddelay=4;;

var sources;;

var gCurrentProgram;; // the list of commands of the current program
var rsctoget;; // list of remaining resources to get for the execution of the current trame
var rscloaded;; // list of resources loaded from current trame
var rsctmp;;    // buffer de chargement des ressources en petits morceaux

// settings, command="IC", managed in eval_IC_msg
var g_streaming_chor_enabled=1;;
var g_cookie="";;
const MASK_BUTTON = 1;;
const MASK_EAR_LEFT = 2;;
const MASK_EAR_RIGHT = 4;;
const MASK_RFID = 8;;
var g_int_mask=0;;
var g_snd_btn_1 = "clonk";;
var g_snd_btn_2 = "chord";;
var g_record_enabled = 1;;

#include protos/interactive_protos.mtl

var gCurAudioCmdIndex=-1;;
var gCurStreamName=nil;;

const BROADCAST_KEYWORD="broadcast";;
const SIGNCUTSIZE=40000;; // taille max du fichier audio de signature

const MSG_IDLE=0x7fffffff;;
const MSG_ASLEEP=0x7ffffffe;;

const STREAMING_PING=60;;
const STD_NET_TIMEOUT=10000;;

const LED_TIMEOUT=600;; // 10 minutes
const CH_frame_duration=1;;
//var CH_set_color=6;;
const CH_set_led_color=7;;
const CH_set_motor=8;;
const CH_set_leds_color=9;; // v16
const CH_set_led_off=10;; // v17
const CH_set_led_palette=14;;
//var CH_set_palette=15;;
const CH_randmidi=16;;
const CH_avance=17;;
const CH_ifne=18;;
const CH_attend=19;;
const CH_setmotordir=20;; // v16


#include utils/palette.mtl
#include utils/const_data.mtl

var midilist;;

fun getmidilist=
    if midilist==nil then set midilist=
    {midi_1noteA4 midi_1noteB5 midi_1noteBb4 midi_1noteC5 midi_1noteE4 midi_1noteF4
     midi_1noteF5 midi_1noteG5 midi_2notesC6C4 midi_2notesC6F5 midi_2notesD4A5
     midi_2notesD4G4 midi_2notesD5G4 midi_2notesE5A5 midi_2notesE5C6 midi_2notesE5E4
     midi_3notesA4G5G5 midi_3notesB5A5F5 midi_3notesB5D5C6 midi_3notesD4E4G4 midi_3notesE5A5C6
     midi_3notesE5C6D5 midi_3notesE5D5A5 midi_3notesF5C6G5};
    midilist;;

fun controlsound s=
    audiolib_wav_start_local s::nil;
    0;;

#include hw/button.mtl

// URLs normales
fun configurl=strcatlist config_get_server_url::"/locate.jsp?sn="::(webmac netMac)::"&h="::(itoa HARDWARE)::"&v="::(getBytecodeRevision)::nil;;
#ifdef PING
fun pingurl =strcatlist pingsrv::"/vl/p4.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&st=1&sd="::(itoh senddata)::"&h="::(itoa HARDWARE)::nil;;
#endif
fun recordurl mode=strcatlist "http://"::config_get_server_url::"/hooks/record.php"::nil;;
fun rfidurl tag=strcatlist pingsrv::"/vl/rfid.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&t="::(webmac tag)::nil;;
fun interactifurl application = strcatlist pingsrv::"/vl/itmode.jsp?sn="::(webmac netMac)::"&v="::(getBytecodeRevision)::"&h="::(itoa HARDWARE)::"&a="::application::nil;;
#ifdef XMPP
fun sendmailxmppurl xmppdomain data = strcatlist pingsrv::"/vl/sendMailXMPP.jsp?m="::(webmac netMac)::"&d="::xmppdomain::"&r="::data::"&v="::(getBytecodeRevision)::nil;;
fun boshurl ip = strcatlist ip::"/http-bind"::nil;;
#endif

// Construction des urls d'interactivité
fun interactifurl_start application= strcatlist (interactifurl application)::"&st=start"::g_cookie::nil;;
fun interactifurl_btn application position cmdindex btn= strcatlist (interactifurl application)::"&st=btn&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&btn="::(itoa btn)::g_cookie::nil;;
fun interactifurl_done application = strcatlist (interactifurl application)::"&st=done"::g_cookie::nil;;
fun interactifurl_ear application position cmdindex earg eard = strcatlist (interactifurl application)::"&st=ear&pos="::(itoa position)::"&idx="::(itoa cmdindex)::"&el="::(itoa earg)::"&er="::(itoa eard)::g_cookie::nil;;
fun interactifurl_reco application position cmdindex = strcatlist (interactifurl application)::"&st=reco&pos="::(itoa position)::"&idx="::(itoa cmdindex)::g_cookie::nil;;

#include srv/meteo.mtl

#ifdef PING
#include srv/ping.mtl
#endif

#ifdef WEBSERVER
#include srv/http_server.mtl
#endif


fun runinit=
    set run=configstartRun;;


fun filterconfig_word s=
    let strstr s " " 0 -> i in
    if i!=nil then [strsub s 0 i strsub s i+1 nil]
    else [s nil];;

fun filterconfig_line s i=
    let strstr s "\10" i-> j in
    if j!=nil then (filterconfig_word strsub s i j-i)::filterconfig_line s j+1
    else if i<strlen s then (filterconfig_word strsub s i nil)::nil;;

fun filterconfig s i0=
    let strreplace s "\13" "" -> s in
    filterconfig_line s i0
;;

fun dump_prgm l=
    Progw "Program:";
    for l=l;l!=nil;tl l do let hd l->[key val] in (
        Progw strcatlist ( key :: " " :: (if (val != nil) then val else "") :: nil)
    );
    Secholn "---";
    l;;


fun _configcbhttp http res=
    if (nil != res) then
    (
        Secholn "config=";
        let filterconfig Secholn httpgetcontent res 0-> conf in
        (
            // http urls
            set pingsrv=listswitchstr conf "ping";
            set broadcasturl=listswitchstr conf "broad";

#ifdef PING
            sleep_end;
            if pingsrv!=nil && broadcasturl!=nil then set run=pingstartRun;
#endif
#ifdef XMPP
        /****** XMPP ****/
            let listswitchstr conf "xmpp_domain" -> xmpp_domain in
                if xmpp_domain != nil then
                    XmppSessionStart xmpp_domain 1; // START 1 XMPP SESSION HERE (1 == Display Leds for connexion Details)

            set run = xmppLoginRun;
#endif
#ifdef SERVERLESS
            sleep_end;
#endif
            0
        )
    )
    else
    (
        // l'appel à locate.jsp a échoué -> ... rebooter tout ?
        Secholn "call to locate.jsp failed, rebooting";
        ///////// reboot 0x0407FE58 0x13fb6754;
        0
    )
;;

var gConfigStart = 0;;
fun runconfigstart=
    if netState==RT2501_S_CONNECTED && wavrunning==0 then (
        set gConfigStart = time_ms;
        leds_set_state LEDS_STATE_CONFIG_WAIT ;
#ifdef SERVERLESS
        meteo_get;
        get_time_from_timeserver;
        sleep_end
#else
        set run=configwaitRun httprequest "GET" Secholn configurl nil #_configcbhttp HTTP_NORMAL
#endif
    );
    0;;

fun runconfigwait http=
    // check timeout and retry : cligne + ou - la led middle body toutes les secondes en bleu
    if ((httpinactive http) > STD_NET_TIMEOUT) then
    (
        Secholn "##timeout on configwait";
        httpabort http;
        set run=configstartRun
    );

    0;;

// Cryptage des trames
fun bintoi3 s x=((strget s x)<<16)+((strget s x+1)<<8)+(strget s x+2);;


/** aide pour la fonction pingextract juste en dessous */
fun pingextract_ s i res=
    if i<strlen s then
    let (strget s i)-> code in
    if code==255 then res
    else if code>=0 && code<=11 then
        let bintoi3 s i+1 -> len in
        if len>=0 then pingextract_ s i+4+len [code strsub s i+4 len]::res;;

/** parse la chaine s et renvoie une liste des commandes contenues dedans */
fun pingextract s=
    if (strget s 0)==0x7f then pingextract_ s 1 nil;;

// replace the prefix string "broadcast" (if present) by broadcasturl
fun rscfilterurl url=
    if 0==strstr url BROADCAST_KEYWORD 0 then strcat broadcasturl strsub url strlen BROADCAST_KEYWORD nil
    else url;;

fun rscFromProgram l=
    if l!=nil then let hd l->[key val] in
    if (!strcmp key "MU") || (!strcmp key "CH") then [val /*nil*/300000]::rscFromProgram tl l
    else if (!strcmp key "MC") then [val SIGNCUTSIZE]::rscFromProgram tl l
    else rscFromProgram tl l;;



var paletteselected = 0;;
// v17 (add romain)
// Fonction permettant d'activer la palette pour le programme en cours
// au jour du 31 mai 2007, on recoit le PL apres le son a jouer, la palette associee au son est donc affichee juste apres la fin du programme
// Cette fonction passe prealablement sur le programme reçu pour mettre la bonne palette
// A noter, si il y a plusieurs palettes dans la trame de retour, seule la premiere est prise en compte
fun CheckForPaletteBefore l=
    for l=l;l!=nil;tl l do let hd l->[key val] in
    (
        if (!strcmp key "PL") && (paletteselected==0) then
        (
            set_current_palette_mode atoi val;
            set paletteselected = 1
        )
    );;

fun prgmStart=
    // Starts playing the program
    // setleds RGB_RED;

    // Si la palette est definie pour ce programme, alors on ne met pas l'aleatoire
    if(paletteselected==0) then (
        set current_palette=tabnew 0 8; // v17 : c'était inversé
        set_current_palette_mode 8 // random palette par défaut
    );
    // start evaluating first command
    set gCurAudioCmdIndex = -1;
    set run=cmdEvalOne 0;
    0;;


// ********** loading resources

// callback from rscLoadWaitRun : a resource has been loaded
fun _rscLoadCBhttp http res maxsize=
    if recording then
    (
        httpabort http;
        nil
    )
    else if res!=nil then
    (
        // received a result, store it in rsctmp
        // Je ne comprends pas la logique ici (AS sept07) : a quoi sert rsctmp et maxsize, et comment passe-t-il à la suite ?
//      Secholn res;
        set rsctmp=res::rsctmp;
        if maxsize!=nil && (slistlen rsctmp)>maxsize then
        (
            // too big ? (?)
            httpabort http;
            _rscLoadCBhttp http nil nil
        );
        0
    )
    else
    (
        let hd rsctoget ->[url _] in
        // remember rsc loaded
        set rscloaded=[url tl rev rsctmp nil]::rscloaded;

        // load next rsc
        set rsctoget=tl rsctoget;
        set run=rscLoadNextRun;
        0
    );;

// Recursive : loads all needed resources of the list 'rsctoget' and then starts current program
fun runRscLoadNext=
    let hd rsctoget -> [url maxsize] in
    if url==nil then
    (
        // nothing (else) to load : start execute msgs now
        Secholn "rsrcs loaded, starting prgm";
        prgmStart;
        0
    )
    else if nil!=listswitchstr rscloaded url then
    (
        // already loaded : load next
        set rsctoget=tl rsctoget;
        runRscLoadNext
    )
    else
    (
        // load resource
        set rsctmp=nil;
        Secho "loading ";
        set run=rscLoadWaitRun httprequest "GET" Secholn (rscfilterurl url) nil (fixarg3 #_rscLoadCBhttp maxsize) HTTP_STREAM;
        0
    );;

fun runRscLoadWait http=
    // wait for loading resource
    if (httpinactive http)>STD_NET_TIMEOUT then
    (
        Secholn "##timeout in runRscLoadWait";
        httpabort http;
        // skip, load next
        set rsctoget=tl rsctoget;
        set run=rscLoadNextRun
    );
    0;;


/**
    Called when a program has to end.
    If doNotNotify is set (!=0) then the server is not notified of the end of the program
*/
fun endOfProgram doNotNotify =
    Secholn "endOfProgram";
    set gProcessingState = 0;
    set gProcessingWaitState = 0; // just in case
    set gCurrentProgram = nil;
    if (gItState && !doNotNotify) then (
        // notifier fini
        interactive_program_done
    ) else (
        // retour normal
        set run = idleRun;
        0
    );
    0;;

#ifdef RECLIB
#include utils/record.mtl
#else
fun record_control mode=0;;
fun record_uploading=0;;
#endif
#include utils/choreographic.mtl
#include utils/interactive.mtl



// ****************************************
// Exécution des chorégraphies de streaming
// v17 - AS 25may07

// - 4 pas de danse fournis (dans chorstream_chorslist)
// - une séquence :
//  - une fois sur chorst_oreille_chance, bouger les oreilles :
//      - pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 4, 8, 12 dents) et, si elle est différente de la position courante, y aller, dans le sens 'vers l'avant'.
//  - tirer un pas de danse au hasard (parmi les 4 fournis)
//  - tirer un nombre de boucles N au hasard entre 3 et 20 (inclus)
//  - tirer un frame_duration au hasard entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
// or les pas durent de 44 à 71 frames, donc le pas dure de 7 à 17 secs,
// donc la séquence dure de 21s à 5m40s
//  -> jouer le pas de danse N fois à ce tempo, puis nouvelle séquence
// A chaque pas de danse : tirer 3 couleurs au hazard dans la palette courante : tete, ventre, pied
// Si palette aléatoire : la changer à toutes les séquences
// sinon, fixée par le serveur.
//
var chorst_pasdedanse;;
var chorst_index;;
var chorst_tempo;;
var chorst_loops;;
var chorst_nexttime;;
var chorst_palettecolors = {0 0 0};;

// v17 AS 25may07 : ratio entre changt de séquence et mvt d'oreille. Plus c'est grand moins souvent les moteurs joueront.
// = 0 : à chaque chgt de seq (en myenne toutes les 2,5 minutes)
// = 1 : une fois sur 2 (soit en moyenne ttes les 5 minutes)
// = 2 : une fois sur 3 (soit en moyenne ttes les 7,5 minutes), etc...
var chorst_oreille_chance;;

// mouvement des leds et oreilles
fun dochorstream=
    if chorst_pasdedanse==nil || ((chorst_index>=strlen chorst_pasdedanse)&&(chorst_loops<1)) then
    (
        // nouvelle séquence
        // Secho "Sequence suivante ";

        // ears enabled ?
        if (g_streaming_chor_enabled) then
        (
        // movements moteur
        // toutes les chorst_oreille_chance fois en moyenne
        // et aussi la première fois forcément histoire de montrer qu'on commence
        if (chorst_pasdedanse == nil) then
        (
            // une des oreilles en haut, une autre en bas : radio...
            if ((random 2) == 1) then (earGo 0 0 0; earGo 1 10 0) else (earGo 0 10 0; earGo 1 0 0);

            // initialisation chorst_oreille_chance
            set chorst_oreille_chance = 0

        ) else if ((random chorst_oreille_chance) == 0) then
        (
            // pour chaque oreille, choisir une position au hasard entre les 4 possibles (0, 5, 10, 14 dents) et, si elle est différente de la position courante, y aller, dans le sens 'vers l'avant'.
            let 0::5::10::14::nil -> ear4Positions in
            (
                let listnth ear4Positions rand&3 -> p in earGo 0 p 0;
                let listnth ear4Positions rand&3 -> p in earGo 1 p 0
            );

            // de moins en moins souvent, puis de nouveau souvent, etc..
            if ((set chorst_oreille_chance = chorst_oreille_chance + 1) > 4) then set chorst_oreille_chance = 0
        )
        );

        // choix d'une séquence = pas de danse (chorst_pasdedanse), tempo et nb de boucles
        set chorst_pasdedanse = listnth chorstream_chorslist Iecholn rand&3;

        set chorst_index=4+1; // on saute le header (4 bytes)
        set chorst_tempo=160+random 90; // entre 16 et 25 (soit entre 160 ms et 250 ms par frame)
        //Secho "tempo "; Iecholn chorst_tempo;
        set chorst_loops=3+random 18; // entre 3 et 20 (inclus)
        //Secho "loops "; Iecholn chorst_loops;

        if (current_palette_is_random) then
            // changer palette courante
            set_current_palette random 7;

        // choisir 3 couleurs au hasard dans la palette
        set chorst_palettecolors={(random 7) (random 7) (random 7)};

        set chorst_nexttime=time_ms

    );

    // continuer à jouer
    while (chorst_index < strlen chorst_pasdedanse) && time_ms >= chorst_nexttime do
    (
        // interprète la choragraphie. Uniquement des set_led_palette et des set_led_off et des set_led_color

        let strget chorst_pasdedanse chorst_index -> cmd in
            // avance l'index de...
            set chorst_index=chorst_index+2+
                if (cmd == CH_set_led_palette) then
                (
                    // palette index
                    let strget chorst_pasdedanse chorst_index+1 -> iled in
                    let strget chorst_pasdedanse chorst_index+2 -> icol in
                    let chorst_palettecolors.(3&icol) -> palcol in
                        // jouer la LED
                        led iled current_palette.palcol;

                    // 2 bytes : led, color
                    2
                )
                else if (cmd == CH_set_led_off) then
                (
                    // off
                    let strget chorst_pasdedanse chorst_index+1 -> iled in
                        led iled 0;

                    // 1 byte : led
                    1
                )
                else if (cmd == CH_set_led_color) then
                (
                    led strget chorst_pasdedanse chorst_index+1
                        ((strget chorst_pasdedanse chorst_index+2)<<16) +
                        ((strget chorst_pasdedanse chorst_index+3)<<8) +
                        ((strget chorst_pasdedanse chorst_index+4));

                        // 6 bytes : 2 qui ne servent à rien
                        6
                )
                else if (cmd==CH_frame_duration) then
                (
                    // on ne le prend pas en compte : c'est chorst_tempo qui gère le tempo
                    // 1 byte : duree
                    1
                )

                else (
                    // problème : commande inconnue : forcer à recommencer au début en incrémentant beaucoup trop
                    Streamw strcatlist "dochorstream : unknown command, restarting dance" :: (itoa cmd) :: nil;
                    strlen chorst_pasdedanse
                );

        // pas de danse fini ?
        if (chorst_index>=strlen chorst_pasdedanse) then
        (
            // on est arrivés au bout du pas de danse
            // next repeat
            set chorst_loops=chorst_loops-1;
            //Secho "loops "; Iecholn chorst_loops;
            if (chorst_loops > 0) then
            (
                // recommencer pas de danse
                set chorst_index=4+1;  // on saute le header (4 bytes)
                // tout de suite
                set chorst_nexttime=time_ms;

                0 // pour avoir le même type de return value que les autres branches du if...

            ) // sinon on laisse chorst_loops = 0 et chorst_index trop loin, ce qui force un passage à la séq suivante

        ) else
            // date de la prochaine commande
            // note : on repart de time_ms, histoire de se caler sur le temps présent et non pas sur le temps de
            // la chorégraphie, sinon, on a des coups de speed car cette fonction n'est pas toujours appelée de manière régulière.
            let strget chorst_pasdedanse chorst_index-1 -> delay in
                set chorst_nexttime = time_ms+delay*chorst_tempo

    );

    0;;

// boucle principale de la chorégraphie de streaming
fun stopStream=
  Streamw "stopStream";
    // oreilles
    earsGoToRefPos;

    set gStreamingState = 0;
    // which resource now ? Can only be interactive or idle
    if (!gBusyState) then ( // don't get a resource if we're busy
    Streamw strcatlist "not busy. gItState : " :: (if (gItState) then "true" else "false") :: nil ;
        if (gItState) then XmppSessionRequestResource "itmode"
        else XmppSessionRequestResource "idle"
    )

    ;;

fun runStreamingCmd i0=
    if wavrunning==0 then (
        // Fin du stream
        stopStream;
        // next command
        set run=cmdEvalOne i0+1;

        nil
    ) else (
        // execute streaming choreography
        if !wav_buffering then dochorstream;

        0
    );;


fun _cbGotoNextCmd i0=
    set run=cmdEvalOne i0+1;
    0;;

fun _cbWavError=
    Streamw "_cbWavError";
    if (gItState) then interactive_error;
    0;;


/**
    quand on a rencontre une instruction "WT" dans un programme, qui demandait
  d'attendre <n> millisecondes avant de continuer le programme
*/
fun runWaitCmd i0 =
    if (time_ms > interactiveWaitEndTime_ms) then
    (
        Xw "runWaitCmd";
        set gProcessingWaitState = 1;
        set run=cmdEvalOne i0+1
    )
;;

//********************************************************
// Executes the i0'th command in the 'gCurrentProgram' program
// a command is a list [key val]
fun runEvalOneCommand i0=
//  Secho "runEvalOneCommand ";Iecholn i0;
    interactive_reset_ears_touched;

    let listnth gCurrentProgram i0 -> [key val] in
    if (/* Secho "eval cmd:";Secholn */ key)==nil then
    (
        // toutes commandes jouées : demander la suite
        endOfProgram 0;
        0
    )
    else if (!strcmp key "MU") || (!strcmp key "MC") then
    (
        Secho "exec "; Secho key; Secholn " : start music";
        set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
        let listswitchstr rscloaded Secholn val -> music in
            if music==nil then Secholn "###nilmusic";
        audiolib_wav_start_local listswitchstr rscloaded val;
        set run=cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "ST" then
    (
        Secholn "exec ST : Start streaming";
        //IPecho netdns 0 1;
        //startdnsclient;
        set gStreamingState = 1;
        setleds 0;
        if !gBusyState then XmppSessionRequestResource "streaming";
        set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
        set gCurStreamName= nil;
        set chorst_pasdedanse=nil;
        let rscfilterurl val -> music in audiolib_start_http music #_cbWavError;
        set run=streamCmdRun i0;
        0
    )
    else if !strcmp key "SP" then
    (
        Secholn "exec SP : Start streaming (protected)";
        //IPecho netdns 0 1;
        //startdnsclient;
        set gStreamingState = 1;
        setleds 0;
        if !gBusyState then XmppSessionRequestResource "streaming";
        set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
        set gCurStreamName= nil;
        set chorst_pasdedanse=nil;
        // Romain
        let rscfilterurl val -> music in (
            set music = strcatlist music::"&sn="::(webmac netMac)::nil;
            let music -> tmpval in (
                set tmpval = md5(strcatlist music::"teloiv"::nil);
                set music = strcatlist music::"&cs="::tmpval::nil
            );
            audiolib_start_http music #_cbWavError
        );
        set run=streamCmdRun i0;
        0
    )
    else if !strcmp key "SI" then
    (
        Secho "exec SI : "; Secholn val;
        // nomme le stream courant
        if gStreamingState then set gCurStreamName = val;
        // play next
        set run=cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "SE" then
    (
        Secho "exec SE : "; Secholn val;
        // stoppe le stream courant s'il est nommé comme ca
        if gStreamingState && (!strcmp gCurStreamName val) then (
            wavstop;
            earStop 0;
            stopStream
        );
        // play next
        set run=cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "MS" then
    (
        Secholn "exec MS : "; Secho val;
        // Music Stream : streams the music (like ST), no choregraphy (assumed to be done by CH), not blocking (like MU)
        set gCurAudioCmdIndex=gCurAudioCmdIndex+1;
        // starts the streamed music
        let rscfilterurl val -> music in audiolib_start_http music #_cbWavError;
        // play next
        set run=cmdEvalOne i0+1;

        0
    )
    else if !strcmp key "MW" then
    (
        // wait for the end of music
        if wavrunning==0 then set run=cmdEvalOne i0+1;
        0
    )
    else if !strcmp key "CH" then
    (
        Secholn "exec CH : "; Secho val;
        msgchorstart (listswitchstr rscloaded val) #_cbGotoNextCmd i0;
        0
    )
    else if !strcmp key "IS" then
    (
        Secho "exec IS : "; Secholn val;
        // Start Interactive mode
        interactive_start val;
        0
    )
    else if !strcmp key "IE" then
    (
        Secholn "exec IE : ";
        // Ends Interactive mode
        interactive_stop;
        0
    )
    else if !strcmp key "WT" then
    (
        Xw strcatlist "exec WT : " :: val :: nil ;
    // need to wait for val miliseconds, staying in interactive mode. at the end, program continues.
    // if button pressed, program stops.
    // if rfid detected, send info.
        set gProcessingWaitState = 1;
      set interactiveWaitEndTime_ms = time_ms + (atoi val);
        set run =   waitCmdRun i0+1;
      0
    )
    else
    (
        Secho key ; Secholn " : "; Secholn val;
        if !strcmp key "PL" then (set_current_palette_mode atoi val;0)
        else if !strcmp key "CL" then (
                let atoi val -> x in set_current_palette_color (x>>24) x&0xffffff;
                0)
        else if !strcmp key "IC" then (eval_IC_msg val;0)
        else (Secholn "unknown, dropping";0);

        // and skip command
        set run=cmdEvalOne i0+1;
        runEvalOneCommand i0+1
    );;

// R=60*((rand&127)+64)) => 64 à 196 mn
// donc si x=30, (x*R)>>7 => 15 à 45 mn
// donc si x=40, (x*R)>>7 => 20 à 61 mn
// donc si x=80, (x*R)>>7 => 40 à 122 mn
// donc si x=216, (x*R)>>7 => 108 à 330 mn
// donc si x=255, (x*R)>>7 => 127 à 390 mn, soit 2 à 6,5h
var nexttaichi;;
fun dotaichinow=
    //Secho "checktaichi ";
    if infotaichi && (infotaichi != nil) && (!gSleepState) then let (if nexttaichi!=nil then (time>nexttaichi) else 0) -> now in (
        if now || nexttaichi==nil then // compute nexttaichi
        let if (infotaichi == 40) then 255 else if (infotaichi == 255) then 40 else 80 -> correctedTaichi in // etait inversé
        let ((correctedTaichi*60*((rand&127)+64))>>7) -> delaye in (
            Secho "taichi in "; Iecho delaye; Secholn "s";
            set nexttaichi=time+delaye
        );
        now
    ) else (
        set nexttaichi=nil;
        0
    );;

fun runEarReset cb=
    if (!earResetting) then
        call cb []
    ;;

#include utils/sleep.mtl

// ******************************************
// Main function : evaluate trame
// trames are sent back from ping and itmode
// a trame contains frames
// a frame can:
// - change the ping delay (type 3)
// - order 'reboot' (type 9)
// - contain new service values and ear positions (type 4)
// - contain a program (type 10)
// In program frames, programs can contain url resources: resources are loaded and stored and then program is executed
// Return the XMPP packet(s) to send or nil.

fun evalTrame ping_trame=
    Secholn "evalTrame >>";
    Secholn ping_trame;
    Secholn "<<";
    let pingextract dump ping_trame -> frame_list in
    if frame_list==nil then (
        // error, bad trame
        Secholn "bad trame";
        dump ping_trame;
        Secholn "dropping";
        if (gItState) then (
            // display error
            interactive_error;
            nil
        ) else (
            // drop, and ping again later
            set run=idleRun;
            nil
        )
    ) else (
        // frame_list ok
        let nil->xmpp_packets in
        let nil->program in
        (
            for l=frame_list;l!=nil;tl l do let hd l-> [code val] in
            (
                let (if code == 3 then (
                    // ping delay
#ifdef PING
                    set pingdelay = strget val 0;
#else
                    Secholn "dropping ping delay";
#endif
                    nil
                ) else if code == 4 then (
                    // update sources, messages number and ears
                    let ((strget val 3) == 0xFF) -> fromHttp in
                    if fromHttp then (
                        // old format
                        infoUpdate strsub val 4 nil;
                        nil
                    ) else (
                        // new format
                        newInfoUpdate strsub val 4 nil;
                        nil
                    )
                ) else if code == 9 then (
                    // reboot
                    //////// reboot 0x0407FE58 0x13fb6754;
                    nil
                ) else if code == 10 then (
                    // programs (or IDLE or SLEEP)
                    uncrypt val 1 nil 0x47 47;
                    set program=dump_prgm filterconfig val 1;
                    nil
                ) else if code == 11 then (
                    // change mode
                    let strget val 0 -> mode in (
                        Secho "changemode = "; Iecholn mode;
                        if (mode == 0) then sleep_end
                        else if (mode == 1) then sleep_start
                        else nil
                    )
                ) else (Secho "Unknown code "; Iecho code; Secholn ""; nil)) -> xmpp_packet_list in
                if (xmpp_packet_list != nil) then
                    set xmpp_packets = xmpp_packet_list::xmpp_packets
                else
                    xmpp_packets
            ); // for l=frame_list

            // post process : a program ?
            if program!=nil then (
                // Initialize Program
                set paletteselected = 0;
                set gCurrentProgram = program;
                set gProcessingState = 1;
                set gProcessingWaitState = 0;
                CheckForPaletteBefore program; // Permet de mettre la palette correspondante au programme, v17 (add romain)
                // resources
                set rsctoget=rscFromProgram program;
                // empties the rsc cache
                set rscloaded=nil;
                let hd rsctoget -> [url _] in
                if url==nil then (
                    // no resources to load : start the program now
                    prgmStart;
                    0
                ) else (
                    // will load rsctoget and then start the program 'gCurrentProgram'
                    Secho "loading rsrcs...";
                    set run = rscLoadNextRun;
                    0
                )
            );
            xmpp_packets
        ) // nil->program
    ) // frame_list != nil
    ;;


//*******************
// Trames queue
var gTramesQueue = nil;;
const TRAME_QUEUE_MAXLEN = 10;;

fun _isResourceValid rsrcName=
    // les règles d'adéquation entre resource et etats
    if (!strcmp rsrcName "urgent") then 1 // tjrs
    else if (!strcmp rsrcName "sources") then 1 // tjrs
    else if (!strcmp rsrcName "boot") then 1 // tjrs
    else if (gStreamingState) then (if (!strcmp rsrcName "streaming") then 1 else 0)
    else if (gItState) then (if (!strcmp rsrcName "itmode") then 1 else 0)
    else if (gSleepState) then (if (!strcmp rsrcName "asleep") then 1 else 0)
    else if (gProcessingState) then 0
    else 1;;

fun _queueTrameRemoveEntry binome=
    // dépile
    set gTramesQueue = remfromlist gTramesQueue binome;

    // was full ?
    let listlen gTramesQueue -> queueLen in
    if queueLen == TRAME_QUEUE_MAXLEN-1 then (
        Secholn "trame queue not full anymore, warning server";
        set gBusyState = 0;
        // which resource now ? Can be in this order asleep, streaming, itmode or idle
        if (gSleepState) then XmppSessionRequestResource "asleep"
        else if (gStreamingState) then XmppSessionRequestResource "streaming"
        else if (gItState) then XmppSessionRequestResource "itmode"
        else XmppSessionRequestResource "idle"
    );
    0;;

fun getNextValidPendingTrame=
    let gTramesQueue -> ptr in
    let nil -> theTrame in (
        while ((theTrame == nil) && ((hd ptr) != nil)) do (
            let hd ptr -> binome in
            let binome -> [rsrc expiration_time ping_trame] in
            if ((expiration_time != nil) && (time >= expiration_time)) then (
                Secholn "trame expired, removing";
                _queueTrameRemoveEntry binome

            ) else if (_isResourceValid rsrc) then (
                // ok
                set theTrame = ping_trame;

                _queueTrameRemoveEntry binome
            );

            // next
            set ptr = tl ptr
        );
        theTrame
    )
    ;;



fun runIdle=
    // if trame waiting, execute it
    let getNextValidPendingTrame -> trame in
    if trame != nil then (
        evalTrame trame;
        0
    ) else (
        set gProcessingState = 0;
#ifdef SERVERLESS
        if check_surprise then (
            surprise;
            0
        )
        else
#endif
        if dotaichinow then (
            taichistart;
            0
        ) else (
#ifdef PING
            runpingstart;
#endif
            0
        )
    );
    0
;;


var gWasNetActivity = 0;;
fun noseled=
    if !earDetecting then
    // led tete clignote if netactivity or wav_buffering //
    let record_uploading || (match run with (rscLoadWaitRun _-> 1)|(interactiveReqWaitRun _->1)|(_->0)) -> netactivity in
    if (netactivity) then (
        led LED_NOSE (if time_ms&256 then RGB_BLUE else RGB_BLACK);
        set gWasNetActivity = 1
    ) else if (wav_buffering) then (
        led LED_NOSE (if time_ms&128 then RGB_VIOLET else RGB_BLACK);
        set gWasNetActivity = 1
    ) else if (gWasNetActivity) then (
        // show off the light
        led LED_NOSE RGB_BLACK;
        set gWasNetActivity = 0
    );
    0;;

fun bottomled=
    if gSleepState == 0 then
    if !earDetecting then
        (let osc time_ms>>4 -> v in led LED_BASE v*0x000100); // pulse green - was violet 0x10001
    0;;

#include hw/rfid.mtl

fun controlplay=
    let buttongetevent -> ev in
    if ev!=nil then (
        Secholn "controlplay";
        wavstop;
        earStop 0;
        let atoi listswitchstr gCurrentProgram "ID" -> id in
            if ev==BUTTON_CLIC then (controlsound midi_abort; if (gStreamingState) then stopStream; endOfProgram 0; XmppSessionSendButtonMsg ev 1 id) //pause
            else if ev==BUTTON_DCLIC then (controlsound midi_ack;if (gStreamingState) then stopStream; endOfProgram 0; XmppSessionSendButtonMsg ev 1 id) //ackall
            else if ev==BUTTON_LCLIC then nil //pause ou record ? callPingRequest 5
    )
    ;;

fun controlwait=
    let buttongetevent -> ev in
    let if ev==nil then eargetevent else ev -> ev in
    if ev!=nil then
    (
        Secho "controlwait ev="; Iecholn ev;
        wavstop;
        earStop 0;
        if ev==BUTTON_CLIC then (hookClick time_ms;0) // click
        else if ev==BUTTON_DCLIC then (controlsound midi_ack; hookDblClick time_ms;0) //ackall
        else if ev==BUTTON_LCLIC then record_control 0  //  //back ou record
        else if ev==BUTTON_DLCLIC then record_control 1 // //back ou record
        else if ev&0x8000 then (
            // oreilles
            controlsound midi_acquired;
            let (ev-0x8000)&0xFF00>>8 -> leftpos in
            let (ev-0x8000)&0xFF -> rightPos in (
                // remember for after sleep, etc...
                set extleft=leftpos;
                set extright=rightPos;
                hookEars leftpos rightPos
            );
            0
        )
    );
    controlrfid
    ;;

fun controlinteractif =
    let buttongetevent -> ev in
    if ev!=nil then
    (
        Secholn "controlinteractif";
        if ev==BUTTON_CLIC || ev==BUTTON_DCLIC then (
            if (g_int_mask&MASK_BUTTON == 0) then interactive_send_btn ev
        ) else if ev==BUTTON_LCLIC then (
            if (g_record_enabled) then (
                // remember wav position and start record
#ifdef RECLIB
                set record_last_wav_bytes = wav_curplayedbytes ;
#endif
                record_control 0
            ) else (
                // like BUTTON_CLIC
                set ev = BUTTON_CLIC;
                if (g_int_mask&MASK_BUTTON == 0) then interactive_send_btn ev
            )
        )
    );
    controlrfid
    ;;


/*
    Utilise dans le cas ou on execute un programme et qu'on est en train
  d'executer une commande "WT". En gros on a un comportement normal
  sauf qu'on lit les rfid en plus
*/
fun controlprogramwait =
    (if (!gItState) then controlplay else controlinteractif) ;
    controlrfid
;;


const CONTROL_WAIT=1;;
const CONTROL_PLAY=2;;
const CONTROL_INTERACTIF=3;;
const CONTROL_PROGRAMWAIT=4;;


fun getRunState =
    run;;

fun setRunState runState =
    let run -> oldRun in (
        set run = runState;
        oldRun
    );;


/**
    Stop everything we can be doing and resets to either idle or asleep
 */
fun stopEverythingAndResetToIdle =
    wavstop;
    stopStream;
    earStartReset;
    set gItState = 0;
    set g_cookie = "";
    set gItApp = nil;
    set gProcessingState = 0;
    set gStreamingState = 0;
    set gCurrentProgram = nil;
    set run = if (!gSleepState) then idleRun else sleepRun;
    0
;;


fun loop=
//Secho "l";
    wifiRun;

    if netState==RT2501_S_IDLE then
    match wifi with
    (initW -> nil)
    |(_ ->
        Secholn "######### wifi lost";
        set wifi=reconnectW;
        earStop 1; // make sure that ears are not moving while we're reconnecting.
        0
    );

    buttonloop;
    let match run with
    ( configstartRun ->
        earRun;
        runconfigstart;
        0)|
    ( configwaitRun http ->
        earRun;
        runconfigwait http;
        0)|
#ifdef PING
    ( pingstartRun ->
        earRun;
        if currentTrameID!=MSG_ASLEEP then bottomled;
        runpingstart;
        0)|
    ( pingwaitRun http ->
        earRun;
        if currentTrameID!=MSG_ASLEEP then (
            infoRun;
            bottomled;
            noseled
        );
        runpingwait http;
        if currentTrameID!=MSG_ASLEEP then CONTROL_WAIT)|
    ( pingRequestWaitRun http->
        bottomled;
        noseled;
        runPingRequestWait http;
        0)|
    ( stdWaitRun t -> earRun;if currentTrameID!=MSG_ASLEEP then (infoRun;bottomled;noseled);runStdWait t; CONTROL_WAIT) |
#endif
#ifdef XMPP
    ( xmppLoginRun ->
    if (earResetting && earsInited) then earRun else earStop 1;
    runLogin;
    CONTROL_WAIT) |
    ( xmppReconnectRun params ->
    if (earResetting && earsInited) then earRun else earStop 1;
    if gSleepState == 0 then (
        // Affichage des sources.
        infoRun;
        // On fige la base en violet
        led LED_BASE RGB_VIOLET
    );
    let params -> [waitTime xSession oldRun] in
        match xSession.sStatus with
            (sOpened -> set run = oldRun; 0)
            |(sClosed ->
                if time_ms > waitTime then (
                    XmppGateReconnect xSession 0
                );
                0)
            |(_ -> 0);
    CONTROL_WAIT)|
#endif
    ( idleRun -> earRun;infoRun;bottomled;noseled;runIdle;CONTROL_WAIT) |
    ( sleepRun -> earRun;runIdle;0) |

    ( rscLoadNextRun -> earRun;infoRun;bottomled;noseled;runRscLoadNext; CONTROL_WAIT)|
    ( rscLoadWaitRun http-> earRun;infoRun;bottomled;noseled;runRscLoadWait http;CONTROL_WAIT)|
    ( cmdEvalOne i-> earRun;runEvalOneCommand i;CONTROL_PLAY)|
    ( chorCmdRun i-> earRun;noseled;runChorCmd i;CONTROL_PLAY)|
    ( streamCmdRun i0-> earRun;noseled;runStreamingCmd i0;CONTROL_PLAY)|
    ( waitCmdRun i -> earRun;noseled;runWaitCmd i;CONTROL_PROGRAMWAIT)|

    ( earResetWaitRun cb -> earRun; runEarReset cb; 0) |

#ifdef RECLIB
    ( recordRun -> runrecord; 0)|
    ( recordStartRun -> runrecordstart; 0) |
#endif

    ( interactiveReqWaitRun http-> earRun;infoRun;bottomled;noseled;runInteractiveReqWait http;CONTROL_WAIT)
     -> keymanager in
    if keymanager==CONTROL_WAIT then
        controlwait
    else if keymanager==CONTROL_PLAY then
        (if (!gItState) then controlplay else controlinteractif)
    else if keymanager==CONTROL_PROGRAMWAIT then
        controlprogramwait
    else
        buttongetevent
    ;

#ifdef XMPP
    XmppSessionRun; // On envois éventuellement les packets en attente
    XmppSessionIdle;
#endif
#ifdef RECLIB
    record_upload_timeout;
#endif
#ifdef SERVERLESS
    run_icmp_ping;
    periodic_send_gratuitous_arp;
#endif
    checkdhcp 0;

    // if ears touched while interactive : process it
    interactiveEarProcessTouched;

    update_time_internal;
    audiolib_wav_time;

    updatevol;
    0;;

fun main=
    leds_set_state LEDS_STATE_START ;
    MACecho netMac 0 1;
    set master=0;
    Secholn ":started";
    config_init;
    wifiInit 0;
    loopcb  #loop;
    infoInit;
    netstart;
    startdnsclient;
    startdhcp;
    Secholn ":done";
    srand time_ms;
    updatevol;
#ifdef WEBSERVER
#ifdef SIMU
    startwebserver 8080;
#else
    startwebserver 80;
#endif
#endif
    runinit;
    interactive_init;
    0;;

#endif // ifdef NOMINAL
